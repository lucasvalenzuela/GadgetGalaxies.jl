var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = GadgetGalaxies","category":"page"},{"location":"#GadgetGalaxies","page":"Home","title":"GadgetGalaxies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GadgetGalaxies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [GadgetGalaxies]","category":"page"},{"location":"#GadgetGalaxies.Galaxy","page":"Home","title":"GadgetGalaxies.Galaxy","text":"Galaxy(snapshot::Snapshot,\n       isub::Integer,\n       subid::Union{HaloID,Nothing},\n       particles::Dict{Symbol,Particles})\n\nGalaxy of a given snapshot (Snapshot) with the zero-based subhalo index isub with Particles. Including subid (containing information on the exact position in the subfind files) makes accessing properties of the galaxy faster than when only having isub.\n\nThe particles are accessible via galaxy.particletype or galaxy[:particletype] (see Particles for typical types).\n\nExamples\n\njulia> p = GadgetGalaxies.Particles(:stars, Dict(\"ID\"=>[1, 2], \"MASS\"=>[1e11, 2e11]));\n\njulia> g = Galaxy(Snapshot(\"box\", 13), 1532, nothing, Dict(:stars=>p));\n\njulia> g.stars === p\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#GadgetGalaxies.Galaxy-Tuple{Snapshot, Integer, Bool}","page":"Home","title":"GadgetGalaxies.Galaxy","text":"Galaxy(snapshot::Snapshot, isub[, get_id=true])\n\nConvenience method for creating a Galaxy with only a snapshot and a subfind id. Will try to read \"MSUB\" to extract the HaloID if get_id is true.\n\nParticles can still be added after initializing the halo by calling for example galaxy.stars = [...].\n\n\n\n\n\n","category":"method"},{"location":"#GadgetGalaxies.Particles","page":"Home","title":"GadgetGalaxies.Particles","text":"Particles(type::Symbol, properties::Dict{String})\n\nParticles of a type (typically :stars, :dm, :gas, or :bh) with their properties in a Dict. The Dict has String keys, which are set to all uppercase by default, with exception of iM and Zs.\n\nThe properties are accessible via particles.prop (case insensitive).\n\nExamples\n\njulia> p = GadgetGalaxies.Particles(:stars, Dict(\"ID\"=>[1, 2], \"MASS\"=>[1e11, 2e11]));\n\njulia> p.id\n2-element Vector{Int64}:\n 1\n 2\n\njulia> p.pos = [1 2; 3 4; 5 6]\n3×2 Matrix{Int64}:\n 1  2\n 3  4\n 5  6\n\njulia> p.properties[\"POS\"] === p.pos\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#GadgetGalaxies.Snapshot","page":"Home","title":"GadgetGalaxies.Snapshot","text":"Snapshot(snapbase, subbase)\n\nReturns a Snapshot from a snapbase and a subbase, which can also be nothing. Both can be files or the base part of files ending with .0, .1, etc.\n\n\n\n\n\n","category":"type"},{"location":"#GadgetGalaxies.Snapshot-Tuple{Any, Integer}","page":"Home","title":"GadgetGalaxies.Snapshot","text":"Snapshot(path_box, snap::Integer; snapbase=true, subbase=true)\n\nConvenience method for creating a Snapshot from the path to a simulated box and a snapshot number. Setting snapbase or subbase to false sets the respective file base to nothing.\n\nThe formats used are the following, for snapbase and subbase, respectively:\n\nsnapdir_XXX/snap_XXX\ngroups_XXX/sub_XXX\n\n\n\n\n\n","category":"method"},{"location":"#GadgetGalaxies.Snapshot-Tuple{}","page":"Home","title":"GadgetGalaxies.Snapshot","text":"Snapshot(; snapbase=nothing, subbase=nothing)\n\nConvenience method for creating a Snapshot where one of the base files does not exist.\n\n\n\n\n\n","category":"method"},{"location":"#GadgetGalaxies.particle_type_id-Tuple{Symbol}","page":"Home","title":"GadgetGalaxies.particle_type_id","text":"particle_type_id(type::Symbol)\n\nReturns the Gadget particle type from a particle Symbol (currently :gas, :dm, :stars,and bh).\n\n\n\n\n\n","category":"method"},{"location":"#GadgetGalaxies.shift_across_box_border-NTuple{4, Number}","page":"Home","title":"GadgetGalaxies.shift_across_box_border","text":"shift_across_box_border(x::Number, x₀::Number, boxsize::Number, boxsize_half::Number)\n\nShift coordinate x across the box border if reference coordinate x₀ is on the other side.\n\n\n\n\n\n","category":"method"}]
}
